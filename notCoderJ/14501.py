'''
    주어지는 상담일 수가 15로 적었기 떄문에 완전 탐색으로 풀 수 있는 문제였지만,
    다이나믹 프로그래밍으로도 풀 수 있다는 생각에 꽂혀 한참을 고민하였다.
    n일자에 최대 수익을 계산하는 점화식을 구해보려고 노력했지만...
    해당일까지 지속되는 상담이나 당일에 상담이 종료되는 경우를 중복없이 계산하는 부분이 쉽지 않았다.
    결국 구글님의 도움으로 힌트를 얻어 N + 1일자에서 최대 수익을 계산하는 방식으로 생각해보았다.
    물론 이것도 잘 이해가 되지 않아 한참을 씨름했다 ㅎㅎ
    시간이 되면 재귀 방식으로도 구현해보며 완전 탐색 방식도 익혀봐야겠다.
        
    풀이 과정:    
        구현한 알고리즘을 요약하면
            어떤 n일에서의 최대 수익은 1부터 n-1일까지 각 일자마다
            해당 일까지의 최대 수익 + 해당 일부터 시작하는 상담 수익(단, n-1일까지 상담이 완료될 경우만 추가해줌)
            값을 계산하여 그 중 가장 큰 값을 선택하면 어떤 n일에서의 최대 수익 값이 된다는 것이다.
            
            이를 점화식으로 표현하면
                "최대 수익(N) = MAX(최대 수익(i) + 해당일 수익(i), 최대 수익(N))" (i는 1 ~ N - 1)
        
        1. 먼저 해당 일자까지 최대 수익을 저장하는 profits이라는 메모이제이션 테이블을 정의한다.
            profits[n]의 의미는 n-1일까지 상담한 것에 대한 최대 수익을 의미한다.
            따라서, n + 1까지의 인덱스를 갖기 위해 n + 2개의 크기로 정의하였다.
        
        2. 1일부터 n + 1일까지 각 일자에서 최대 수익을 계산하기 위해 위에서 정의한 점화식을 반복한다.
        
        3. 퇴사 일에서의 최대 수익을 출력한다.(N일까지 근무 후 N + 1일에 퇴사한다면 최대 수익은 profits[N + 1]이다.)
'''

n = int(input())

# 주어진 상담일자를 맞추기 위해 0번 인덱스에 (0, 0) 값을 추가해줌
tasks = [(0, 0)] + [tuple(map(int, input().split())) for _ in range(n)]
profits = [0 for _ in range(n + 2)]

for d in range(1, n + 2):
    for i, t in enumerate(tasks[:d]):
        if i + t[0] <= d: # 상담 종료일이 보수 정산일 이전일 경우만 고려하여 해당일에서 최대 수익을 계산함
            profits[d] = max(profits[i] + t[1] , profits[d])

print(profits[n + 1])